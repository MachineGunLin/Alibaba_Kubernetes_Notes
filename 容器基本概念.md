# 容器基本概念

背景：操作系统可以通过ps等命令查看进程。这些进程有几个特点：

（1）这些进程可以相互看到、相互通信

（2）这些进程使用的是同一个文件系统，可以对同一个文件系统进行读写操作

（3）这些进程使用相同的系统资源

特点（1）可能会导致高级权限的进程攻击低级权限的进程；特点（2）可能导致具有高级权限的进程对文件的增删改查破坏了低级权限进程的数据；特点（3）带来的问题是：由于使用相同的系统资源，所以应用之间会进行资源的抢占。

### Linux操作系统的解决方法（容器）

Linux和UNIX操作系统可以通过chroot系统调用将子目录变成根目录进行视图级别的隔离（针对文件系统，视图隔离：能够看到部分进程以及具有独立的主机名）；Namespace技术可以将资源进行视图级别的隔离；Cgroup用来限制进程的资源使用率（比如可以设置能够使用的CPU及内存量）来减小进程彼此之间的影响。

***上述的进程集合就叫做 容器***

**容器就是一个视图隔离、资源可限制、独立文件系统的进程集合**



### 镜像

***容器运行时所需要的所有文件集合称为镜像***

一般通过Dockerfile来构建镜像，Dockerfile可以很好地描述构建镜像的每个步骤。每个构建步骤都会对已有的文件系统进行操作并产生变化，这些变化成为changeset。当把构建步骤所产生的变化依次作用到一个空文件夹上，就能得到一个完整的镜像。

构建镜像举例（构建golang应用）：

![img](./pic/1615473ad962096446.png)

解释：

1. FROM表示基于golang:1.12-alpine镜像构建
2. WORKDIR表示接下来的构建步骤都在/go/src/app目录下进行，有点类似linux的cd命令
3. COPY行表示可以将宿主机上的文件拷贝到容器镜像内
4. RUN行表示在具体的文件系统内执行相应的动作。运行完毕后就得到一个应用了
5. CMD行表示使用镜像时的默认程序名字

有了Dockerfile之后就可以通过docker build命令构建应用，构建出的结果存储在本地。

为了让镜像在生产环境或测试环境下运行，需要一个存储镜像的仓库，于是便有了docker registry，也就是镜像仓库，顾名思义就是存储所有的镜像，在本地使用docker push就可以把镜像推到镜像仓库中，这样就可以在生产环境或测试环境通过docker pull拉取镜像并运行。



### 如何运行容器

（1）从镜像仓库拉取镜像

（2）拉取镜像后可以通过docker images查看本地镜像，会显示本地的所有镜像，在列表中选择想要的镜像

（3）选好镜像后，使用docker run镜像就可以得到想要的容器。多次运行可以得到多个容器。镜像就相当于是一个模板，容器就是镜像的一个具体的运行实例。所以说镜像有“一次构建，到处运行”的特点



## 容器和虚拟机的差异

每个虚拟机的操作系统都是独立的，在不同虚拟机上的应用都是独立的，虚拟机提供很好的隔离效果，但这需要代价，也就是说需要将一部分计算资源用来虚拟化，还有一个代价就是每个虚拟机的操作系统都需要占用大量磁盘空间，这也导致了虚拟机启动慢。

**由于需要虚拟化占用计算资源、操作系统占用磁盘空间、虚拟机启动慢等特点，于是便有了 容器**

容器相对虚拟机而言无需独立的操作系统，只需要一个独立的文件系统提供其所需要的文件集合即可。所有的文件隔离都是进程级别，引起容器启动速度快、需要磁盘空间小。代价就是隔离效果不如虚拟机。
